
// D_main.c

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

#include <SDL.h>

#include "doomdef.h"
#include "p_local.h"
#include "soundst.h"

#include "i_video.h"
#include "i_system.h"
#include "i_net.h"
#include "i_audio.h"

boolean shareware = false;		// true if only episode 1 present
boolean ExtendedWAD = false;	// true if episodes 4 and 5 present

boolean nomonsters;			// checkparm of -nomonsters
boolean respawnparm;			// checkparm of -respawn
boolean debugmode;			// checkparm of -debug
boolean ravpic;				// checkparm of -ravpic
boolean cdrom;					// true if cd-rom mode active
boolean singletics;			// debug flag to cancel adaptiveness
boolean noartiskip;			// whether shift-enter skips an artifact

boolean devparm = false;

skill_t startskill;
int startepisode;
int startmap;
boolean autostart;
extern boolean automapactive;

boolean advancedemo;

FILE *debugfile;

void D_CheckNetGame(void);
void D_ProcessEvents(void);
void G_BuildTiccmd(ticcmd_t *cmd);
void D_DoAdvanceDemo(void);
void D_PageDrawer (void);
void D_AdvanceDemo (void);
void F_Drawer(void);
boolean F_Responder(event_t *ev);

/*
===============================================================================

							EVENT HANDLING

Events are asyncronous inputs generally generated by the game user.

Events can be discarded if no responder claims them

===============================================================================
*/

event_t events[MAXEVENTS];
int eventhead;
int eventtail;

//---------------------------------------------------------------------------
//
// PROC D_PostEvent
//
// Called by the I/O functions when input is detected.
//
//---------------------------------------------------------------------------

void D_PostEvent(event_t *ev)
{
	events[eventhead++] = *ev;
	eventhead &= MAXEVENTS-1;
}

//---------------------------------------------------------------------------
//
// PROC D_ProcessEvents
//
// Send all the events of the given timestamp down the responder chain.
//
//---------------------------------------------------------------------------

void D_ProcessEvents(void)
{
	event_t *ev;

	for(; eventtail != eventhead; eventtail = (++eventtail)&(MAXEVENTS-1))
	{
		ev = &events[eventtail];
		if(F_Responder(ev))
		{
			continue;
		}
		if(MN_Responder(ev))
		{
			continue;
		}
		G_Responder(ev);
	}
}

//---------------------------------------------------------------------------
//
// PROC DrawMessage
//
//---------------------------------------------------------------------------

void DrawMessage(void)
{
	player_t *player;

	player = &players[consoleplayer];
	if(player->messageTics <= 0 || !player->message)
	{ // No message
		return;
	}
	MN_DrTextA(player->message, (SCREENWIDTH-MN_TextAWidth(player->message))/2, 1);
}

//---------------------------------------------------------------------------
//
// PROC D_Display
//
// Draw current display, possibly wiping it from the previous.
//
//---------------------------------------------------------------------------

extern boolean finalestage;
extern int InfoType;

void D_Display(void)
{
	extern boolean MenuActive;
	extern boolean askforquit;

	// Change the view size if needed
	if(setsizeneeded)
	{
		R_ExecuteSetViewSize();
	}

//
// do buffered drawing
//
	if (!InfoType) {
		switch (gamestate) {
			case GS_LEVEL:
				if (!gametic)
					break;
				if (automapactive)
					AM_Drawer ();
				else
					R_RenderPlayerView (&players[displayplayer]);
				CT_Drawer();
				UpdateState |= I_FULLVIEW;
				SB_Drawer();
				break;
			case GS_INTERMISSION:
				IN_Drawer ();
				break;
			case GS_FINALE:
				F_Drawer ();
				break;
			case GS_DEMOSCREEN:
				D_PageDrawer ();
				break;
		}
	}

	if(paused && !MenuActive && !askforquit)
	{
		if(!netgame)
		{
			V_DrawPatch(160, viewwindowy+5, W_CacheLumpName("PAUSED",
				PU_CACHE));
		}
		else
		{
			V_DrawPatch(160, 70, W_CacheLumpName("PAUSED",
				PU_CACHE));
		}
	}

	if (!InfoType) {
		// Handle player messages
		DrawMessage();
	}

	// Menu drawing
	MN_Drawer();

	// Send out any new accumulation
	NetUpdate();

	// Flush buffered stuff to screen
	I_Update();
}

//---------------------------------------------------------------------------
//
// PROC D_DoomLoop
//
//---------------------------------------------------------------------------

void D_DoomLoop(void)
{
	if(M_CheckParm("-debugfile")) {
		char filename[20];
		sprintf(filename, "debug%i.txt", consoleplayer);
		debugfile = fopen(filename,"w");
	}

	I_InitGraphics();
	for(;;)
	{
		// Process one or more tics
		if(singletics)
		{
			I_StartTic();
			D_ProcessEvents();
			G_BuildTiccmd(&netcmds[consoleplayer][maketic%BACKUPTICS]);
			if (advancedemo)
				D_DoAdvanceDemo ();
			G_Ticker();
			gametic++;
			maketic++;
		}
		else
		{
			// Will run at least one tic
			TryRunTics();
		}

		// Move positional sounds
		S_UpdateSounds(players[consoleplayer].mo);
		D_Display();
	}
}

/*
===============================================================================

						DEMO LOOP

===============================================================================
*/

int             demosequence;
int             pagetic;
char            *pagename;


/*
================
=
= D_PageTicker
=
= Handles timing for warped projection
=
================
*/

void D_PageTicker (void)
{
	if (--pagetic < 0)
		D_AdvanceDemo ();
}


/*
================
=
= D_PageDrawer
=
================
*/

extern boolean MenuActive;

void D_PageDrawer(void)
{
	V_DrawRawScreen(W_CacheLumpName(pagename, PU_CACHE));
	if(demosequence == 1)
	{
		V_DrawPatch(4, 160, W_CacheLumpName("ADVISOR", PU_CACHE));
	}
	UpdateState |= I_FULLSCRN;
}

/*
=================
=
= D_AdvanceDemo
=
= Called after each demo or intro demosequence finishes
=================
*/

void D_AdvanceDemo (void)
{
	advancedemo = true;
}

void D_DoAdvanceDemo (void)
{
	players[consoleplayer].playerstate = PST_LIVE;  // don't reborn
	advancedemo = false;
	usergame = false;               // can't save / end game here
	paused = false;
	gameaction = ga_nothing;
	demosequence = (demosequence+1)%7;
	switch (demosequence)
	{
		case 0:
			pagetic = 210;
			gamestate = GS_DEMOSCREEN;
			pagename = "TITLE";
			S_StartSong(mus_titl, false);
			break;
		case 1:
			pagetic = 140;
			gamestate = GS_DEMOSCREEN;
			pagename = "TITLE";
			break;
		case 2:
			BorderNeedRefresh = true;
			UpdateState |= I_FULLSCRN;
			G_DeferedPlayDemo ("demo1");
			break;
		case 3:
			pagetic = 200;
			gamestate = GS_DEMOSCREEN;
			pagename = "CREDIT";
			break;
		case 4:
			BorderNeedRefresh = true;
			UpdateState |= I_FULLSCRN;
			G_DeferedPlayDemo ("demo2");
			break;
		case 5:
			pagetic = 200;
			gamestate = GS_DEMOSCREEN;
			if(shareware)
			{
				pagename = "ORDER";
			}
			else
			{
				pagename = "CREDIT";
			}
			break;
		case 6:
			BorderNeedRefresh = true;
			UpdateState |= I_FULLSCRN;
			G_DeferedPlayDemo ("demo3");
			break;
	}
}


/*
=================
=
= D_StartTitle
=
=================
*/

void D_StartTitle (void)
{
	gameaction = ga_nothing;
	demosequence = -1;
	D_AdvanceDemo ();
}


/*
==============
=
= D_CheckRecordFrom
=
= -recordfrom <savegame num> <demoname>
==============
*/

void D_CheckRecordFrom (void)
{
	int     p;
	char    file[256];

	p = M_CheckParm ("-recordfrom");
	if (!p || p > myargc-2)
		return;

	if(cdrom)
	{
		sprintf(file, SAVEGAMENAMECD"%c.hsg",myargv[p+1][0]);
	}
	else
	{
		char *home = getenv("HOME");
		if (!home) {
			sprintf(file, SAVEGAMENAME"%c.hsg",myargv[p+1][0]);
		} else {
			sprintf(file, "%s/.heretic/"SAVEGAMENAME"%c.hsg",home,myargv[p+1][0]);
		}
	}
	G_LoadGame (file);
	G_DoLoadGame ();    // load the gameskill etc info from savegame

	G_RecordDemo (gameskill, 1, gameepisode, gamemap, myargv[p+2]);
	D_DoomLoop ();  // never returns
}

/*
===============
=
= D_AddFile
=
===============
*/

#define MAXWADFILES 20

// MAPDIR should be defined as the directory that holds development maps
// for the -wart # # command

#define MAPDIR "\\data\\"

#define SHAREWAREWADNAME "heretic1.wad"

char *wadfiles[MAXWADFILES] =
{
	"heretic.wad",
	"texture1.lmp",
	"texture2.lmp",
	"pnames.lmp"
};

char basedefault[1024];/* = "heretic.cfg";*/

char exrnwads[80];
char exrnwads2[80];

void wadprintf(void)
{
	if(debugmode)
	{
		return;
	}
	#ifdef __WATCOMC__
	_settextposition(23, 2);
	_setbkcolor(1);
	_settextcolor(0);
	_outtext(exrnwads);
	_settextposition(24, 2);
	_outtext(exrnwads2);
	#endif
}

void D_AddFile(char *file)
{
	int numwadfiles;
	char *new;
//	char text[256];

	for(numwadfiles = 0; wadfiles[numwadfiles]; numwadfiles++);
	new = malloc(strlen(file)+1);
	strcpy(new, file);
	if(strlen(exrnwads)+strlen(file) < 78)
	{
		if(strlen(exrnwads))
		{
			strcat(exrnwads, ", ");
		}
		else
		{
			strcpy(exrnwads, "External Wadfiles: ");
		}
		strcat(exrnwads, file);
	}
	else if(strlen(exrnwads2)+strlen(file) < 79)
	{
		if(strlen(exrnwads2))
		{
			strcat(exrnwads2, ", ");
		}
		else
		{
			strcpy(exrnwads2, "     ");
			strcat(exrnwads, ",");
		}
		strcat(exrnwads2, file);
	}
	wadfiles[numwadfiles] = new;
}

//---------------------------------------------------------------------------
//
// PROC D_DoomMain
//
//---------------------------------------------------------------------------

void D_DoomMain(void)
{
	int p;
	int e;
	int m;
	char file[256];
	FILE *fp;
	boolean devMap;
	//char *screen;
	char *home = getenv("HOME");

	if (home) {
		sprintf(file, "%s/.heretic", home);
		mkdir(file, 0755);
	}

	M_FindResponseFile();
	setbuf(stdout, NULL);
	nomonsters = M_CheckParm("-nomonsters");
	respawnparm = M_CheckParm("-respawn");
	ravpic = M_CheckParm("-ravpic");
	noartiskip = M_CheckParm("-noartiskip");
	debugmode = M_CheckParm("-debug");
	startskill = sk_medium;
	startepisode = 1;
	startmap = 1;
	autostart = false;

	p=M_CheckParm ("-width");
    if (p && (p<myargc-1)) {
		sysvideo.width = atoi(myargv[p+1]);
	}
	p=M_CheckParm ("-height");
    if (p && (p<myargc-1)) {
		sysvideo.height = atoi(myargv[p+1]);
	}
	p=M_CheckParm ("-bpp");
    if (p && (p<myargc-1)) {
		sysvideo.bpp = atoi(myargv[p+1]);
	}
	p=M_CheckParm ("-fullscreen");
    if (p) {
		sysvideo.fullscreen = true;
	}
	p=M_CheckParm ("-resize");
    if (p) {
		sysvideo.resize = true;
	}
	p=M_CheckParm ("-flat");
    if (p) {
		sysvideo.textured_spans = false;
	}
	p=M_CheckParm ("-yieldcpu");
    if (p && (p<myargc-1)) {
		if (strcmp(myargv[p+1],"off")==0) {
			sysvideo.yield_cpu = false;
		}
		if (strcmp(myargv[p+1],"on")==0) {
			sysvideo.yield_cpu = true;
		}
	}

	p=M_CheckParm ("-network");
    if (p && (p<myargc-1)) {
		if (strcmp(myargv[p+1],"sting")==0) {
			sysnetwork.layer = NETWORK_STING;
		}
	}
	sysaudio.enabled=true;
	p=M_CheckParm ("-audio");
    if (p && (p<myargc-1)) {
		if (strcmp(myargv[p+1],"off")==0) {
			sysaudio.enabled = false;
		}
	}
	p=M_CheckParm ("-mem");
    if (p && (p<myargc-1)) {
		sysgame.kb_used = atoi(myargv[p+1]);
		if (sysgame.kb_used<MINIMAL_HEAP_SIZE)
			sysgame.kb_used=MINIMAL_HEAP_SIZE;
	}
	p=M_CheckParm ("-devparm");
    if (p) {
		devparm = true;
	}

	// wadfiles[0] is a char * to the main wad
	fp = fopen(wadfiles[0], "rb");
	if(fp)
	{
		fclose(fp);
	}
	else
	{ // Change to look for shareware wad
		wadfiles[0] = SHAREWAREWADNAME;
	}

	// Check for -CDROM
	cdrom = false;
#ifdef __WATCOMC__
	if(M_CheckParm("-cdrom"))
	{
		cdrom = true;
		mkdir("c:\\heretic.cd");
	}
#endif

	// -FILE [filename] [filename] ...
	// Add files to the wad list.
	p = M_CheckParm("-file");
	if(p)
	{	// the parms after p are wadfile/lump names, until end of parms
		// or another - preceded parm
		while(++p != myargc && myargv[p][0] != '-')
		{
			D_AddFile(myargv[p]);
		}
	}

	// -DEVMAP <episode> <map>
	// Adds a map wad from the development directory to the wad list,
	// and sets the start episode and the start map.
	devMap = false;
	p = M_CheckParm("-devmap");
	if(p && p < myargc-2)
	{
		e = myargv[p+1][0];
		m = myargv[p+2][0];
		sprintf(file, MAPDIR"E%cM%c.wad", e, m);
		D_AddFile(file);
		printf("DEVMAP: Episode %c, Map %c.\n", e, m);
		startepisode = e-'0';
		startmap = m-'0';
		autostart = true;
		devMap = true;
	}

	p = M_CheckParm("-playdemo");
	if(!p)
	{
		p = M_CheckParm("-timedemo");
	}
	if (p && p < myargc-1)
	{
		sprintf(file, "%s.lmp", myargv[p+1]);
		D_AddFile(file);
		printf("Playing demo %s.lmp.\n", myargv[p+1]);
	}

//
// get skill / episode / map from parms
//
	if(M_CheckParm("-deathmatch"))
	{
		deathmatch = true;
	}

	p = M_CheckParm("-skill");
	if(p && p < myargc-1)
	{
		startskill = myargv[p+1][0]-'1';
		autostart = true;
	}

	p = M_CheckParm("-episode");
	if(p && p < myargc-1)
	{
		startepisode = myargv[p+1][0]-'0';
		startmap = 1;
		autostart = true;
	}

	p = M_CheckParm("-warp");
	if(p && p < myargc-2)
	{
		startepisode = myargv[p+1][0]-'0';
		startmap = myargv[p+2][0]-'0';
		autostart = true;
	}

//
// init subsystems
//
	printf("Z_Init: Init zone memory allocation daemon.\n");
	Z_Init();

	printf("V_Init: allocate screens.\n");
	V_Init();

	// Load defaults before initing other systems
	printf("M_LoadDefaults: Load system defaults.\n");
	M_LoadDefaults();

	printf("W_Init: Init WADfiles.\n");
	W_InitMultipleFiles(wadfiles);

	if(W_CheckNumForName("E2M1") == -1)
	{ // Can't find episode 2 maps, must be the shareware WAD
		shareware = true;
	}
	else if(W_CheckNumForName("EXTENDED") != -1)
	{ // Found extended lump, must be the extended WAD
		ExtendedWAD = true;
	}

	wadprintf(); // print the added wadfiles

	printf("MN_Init: Init menu system.\n");
	MN_Init();

	CT_Init();

	printf("R_Init: Init Heretic refresh daemon.");
	R_Init();

	printf("\nP_Init: Init Playloop state.\n");
	P_Init();

	printf("I_Init: Setting up machine state.\n");
	I_Init();

	printf("D_CheckNetGame: Checking network game status.\n");
	D_CheckNetGame();

	printf("SB_Init: Loading patches.\n");
	SB_Init();

//
// start the apropriate game based on parms
//

	D_CheckRecordFrom();

	p = M_CheckParm("-record");
	if(p && p < myargc-1)
	{
		G_RecordDemo(startskill, 1, startepisode, startmap, myargv[p+1]);
		D_DoomLoop(); // Never returns
	}

	p = M_CheckParm("-playdemo");
	if(p && p < myargc-1)
	{
		singledemo = true; // Quit after one demo
		G_DeferedPlayDemo(myargv[p+1]);
		D_DoomLoop(); // Never returns
	}

	p = M_CheckParm("-timedemo");
	if(p && p < myargc-1)
	{
		G_TimeDemo(myargv[p+1]);
		D_DoomLoop(); // Never returns
	}

	p = M_CheckParm("-loadgame");
	if(p && p < myargc-1)
	{
		if(cdrom)
		{
			sprintf(file, SAVEGAMENAMECD"%c.hsg", myargv[p+1][0]);
		}
		else
		{
			if (!home) {
				sprintf(file, SAVEGAMENAME"%c.hsg", myargv[p+1][0]);
			} else {
				sprintf(file, "%s/.heretic/"SAVEGAMENAME"%c.hsg", home,myargv[p+1][0]);
			}
		}
		G_LoadGame(file);
	}

	// Check valid episode and map
	if((autostart || netgame) && (devMap == false))
	{
		if(M_ValidEpisodeMap(startepisode, startmap) == false)
		{
			startepisode = 1;
			startmap = 1;
		}
	}

	if(gameaction != ga_loadgame)
	{
		UpdateState |= I_FULLSCRN;
		BorderNeedRefresh = true;
		if(autostart || netgame)
		{
			G_InitNew(startskill, startepisode, startmap);
		}
		else
		{
			D_StartTitle();
		}
	}

	D_DoomLoop(); // Never returns
}
